# Run github actions locally with act https://github.com/nektos/act
# act --container-architecture linux/amd64 --artifact-server-path ./build/artifacts -W ./.github/workflows/build.yml

name: Build
permissions:
  contents: read

on:
  push:
    branches: [main]
    tags: ['*']
  pull_request:

jobs:
  pipeline_check:
    runs-on: ubuntu-latest
    outputs:
      skip_pipeline: ${{ steps.calculate_skip_pipeline.outputs.skip_pipeline }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - id: calculate_skip_pipeline
        shell: bash
        run: |
          # Default for non-PR events: always run the pipeline
          if [[ "$GITHUB_EVENT_NAME" != "pull_request" ]]; then
            echo "skip_pipeline=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BASE_SHA='${{ github.event.pull_request.base.sha }}'
          HEAD_SHA='${{ github.event.pull_request.head.sha }}'

          echo "Base: $BASE_SHA"
          echo "Head: $HEAD_SHA"

          # List changed files between base and head
          mapfile -t files < <(git diff --name-only "$BASE_SHA" "$HEAD_SHA")

          if [[ "${#files[@]}" -eq 0 ]]; then
            # No changes? Be safe and run the pipeline
            echo "skip_pipeline=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          skip_pipeline=true
          for f in "${files[@]}"; do
            echo "Changed: $f"
            if [[ "$f" != terragrunt/* ]]; then
              skip_pipeline=false
              break
            fi
          done

          echo "skip_pipeline=$skip_pipeline" >> "$GITHUB_OUTPUT"

  test:
    needs: pipeline_check
    runs-on: ubuntu-latest
    name: Tests
    strategy:
      matrix:
        dotnet-version: [ '8.0.x' ]

    steps:
      - name: Short-circuit for infra-only PRs
        if: needs.pipeline_check.outputs.skip_pipeline == 'true'
        run: echo "Infra-only PR (terragrunt/**); skipping tests."
      - uses: actions/checkout@v4
        if: needs.pipeline_check.outputs.skip_pipeline != 'true'      
      - name: Setup dotnet ${{ matrix.dotnet-version }}
        if: needs.pipeline_check.outputs.skip_pipeline != 'true'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ matrix.dotnet-version }}      
      - uses: actions/cache@v4
        if: needs.pipeline_check.outputs.skip_pipeline != 'true'
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget
      - name: Build
        if: needs.pipeline_check.outputs.skip_pipeline != 'true'
        run: make build OpenAPI
      - name: Test
        if: needs.pipeline_check.outputs.skip_pipeline != 'true'
        run: make test TEST_OPTIONS="--logger trx --results-directory 'TestResults-${{ matrix.dotnet-version }}'"
      - name: Upload test results
        if: always() && needs.pipeline_check.outputs.skip_pipeline != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: test-results-dotnet-${{ matrix.dotnet-version }}
          path: TestResults-${{ matrix.dotnet-version }}
      - name: Upload OpenAPI contracts
        if: needs.pipeline_check.outputs.skip_pipeline != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: OpenAPI
          path: OpenAPI

  package:
    needs: pipeline_check
    if: github.event_name != 'pull_request' || needs.pipeline_check.outputs.skip_pipeline == 'false'
    runs-on: ubuntu-latest
    name: Build containers
    env:
      DOCKER_BUILDKIT: 1
      COMPOSE_DOCKER_CLI_BUILD: 1
    outputs:
      version: ${{ steps.version.outputs.version }}
      images: ${{ steps.save.outputs.images }}
      images_json: ${{ steps.save.outputs.images_json }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Determine the version
        id: version
        run: |
          COMMIT_REF=$(if [ "$GITHUB_EVENT_NAME" == "pull_request" ]; then echo "${{ github.event.pull_request.head.sha }}"; else echo "${GITHUB_SHA:-HEAD}"; fi)
          CURRENT_COMMIT=$(make version-commit COMMIT_REF=$COMMIT_REF)
          CURRENT_TAG=$([[ "${GITHUB_REF:0:10}" = "refs/tags/" ]] && echo ${GITHUB_REF#refs/tags/} || echo "")
          LAST_TAG=$(make last-tag)
          VERSION=$([[ "${CURRENT_TAG}" = "" ]] && echo "${LAST_TAG}-${CURRENT_COMMIT}" || echo "$CURRENT_TAG")
          echo "Version: $VERSION"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
      - name: Build
        run: make build-docker VERSION=${IMAGE_VERSION}
        env:
          IMAGE_VERSION: ${{ steps.version.outputs.version }}
      - name: Start services
        run: make up
        env:
          IMAGE_VERSION: ${{ steps.version.outputs.version }}
          SIRSI_ONELOGIN_CLIENTID: ${{ secrets.SIRSI_ONELOGIN_CLIENTID }}
          SIRSI_ONELOGIN_PRIVATEKEY: ${{ secrets.SIRSI_ONELOGIN_PRIVATEKEY }}
          SIRSI_ORGANISATION_APP_COMPANIESHOUSE_USER: ${{ secrets.SIRSI_ORGANISATION_APP_COMPANIESHOUSE_USER }}
          SIRSI_ORGANISATION_APP_CHARITYCOMMISSION_SUBSCRIPTIONKEY: ${{ secrets.SIRSI_ORGANISATION_APP_CHARITYCOMMISSION_SUBSCRIPTIONKEY }}
          Organisation__Authority: http://authority:8080
          OrganisationService: http://organisation:8080
          FormsService: http://forms:8080
          PersonService: http://person:8080
          TenantService: 'http://tenant:8080'
          DataSharingService: http://data-sharing:8080
          EntityVerificationService: http://entity-verification:8080
          CommercialToolsApp: http://commercial-tools-app:8080
          CommercialToolsApi: http://commercial-tools-api:8080
          SirsiService: http://organisation-app:8080
      - name: Verify services
        run: make verify-up
        env:
          IMAGE_VERSION: ${{ steps.version.outputs.version }}
      - name: Test migrations
        run: make db
        env:
          IMAGE_VERSION: ${{ steps.version.outputs.version }}
      - name: Run E2E Tests
        run: make e2e-test
        env:
          TestSettings__Email: ${{ secrets.SIRSI_E2ETEST_EMAIL }}
          TestSettings__Password: ${{ secrets.SIRSI_E2ETEST_PASSWORD }}
          TestSettings__SecretKey: ${{ secrets.SIRSI_E2ETEST_SECRETKEY }}
          TestSettings__TestSupportAdminEmail: ${{ secrets.SIRSI_E2ETEST_SUPPORTADMINEMAIL }}
          TestSettings__TestSupportAdminPassword: ${{ secrets.SIRSI_E2ETEST_SUPPORTADMINPASSWORD }}
          TestSettings__TestSupportAdminSecretKey: ${{ secrets.SIRSI_E2ETEST_SUPPORTADMINSECRETKEY }}
          Organisation__Authority: http://authority:8080
          OrganisationService: http://organisation:8080
          FormsService: http://forms:8080
          PersonService: http://person:8080
          TenantService: 'http://tenant:8080'
          DataSharingService: http://data-sharing:8080
          EntityVerificationService: http://entity-verification:8080
          CommercialToolsApp: http://commercial-tools-app:8080
          CommercialToolsApi: http://commercial-tools-api:8080
          SirsiService: http://organisation-app:8080
      - name: Grab Docker logs
        if: failure()
        run: |
          mkdir -p logs
          docker compose ps --services | while read -r svc; do
            docker compose logs --no-color --timestamps "$svc" > "logs/${svc}.log" 2>&1 || echo "No logs for $svc"
          done
      - name: Upload Docker Logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: docker-logs
          path: logs
      - name: Upload E2E failure screenshots
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-screenshots
          path: '**/Screenshots/*.png'
      - name: Upload Playwright traces
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-traces
          path: '**/Traces/*.zip'
      - name: Stop services
        run: make down
        env:
          IMAGE_VERSION: ${{ steps.version.outputs.version }}
      - name: Save Docker Images
        id: save
        run: |
          IMAGES=$(docker images --format '{{.Repository}}:{{.Tag}}' | awk -F: -v version="$IMAGE_VERSION" '$1 ~ /cabinetoffice\/cdp-/ && $2 == version { print $1":"$2 }' | tr '\n' ' ')
          IMAGES_JSON=$(echo $IMAGES | tr " " "\n" | jq -R . | jq -c -s .)
          echo "Images to be saved: $IMAGES"
          echo "Images to be saved (json): $IMAGES_JSON"
          docker save -o cdp-images.tar $IMAGES
          echo "images=${IMAGES}" >> $GITHUB_OUTPUT
          echo "images_json=${IMAGES_JSON}" >> $GITHUB_OUTPUT
        env:
          IMAGE_VERSION: ${{ steps.version.outputs.version }}
      - name: Upload Docker Images as Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: docker-images
          path: cdp-images.tar

  vulnerability-scan:
    # since we do not fail the build for now, but the report is to get feedback, only run it on the main branch and tags
    if: (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')) && github.repository_owner == 'cabinetoffice'
    runs-on: ubuntu-latest
    name: Scan for vulnerabilities
    needs: [test, package]
    permissions:
      contents: read
      security-events: write  # needed for upload-sarif / code scanning
    strategy:
      matrix:
        image: ${{ fromJSON(needs.package.outputs.images_json) }}
    steps:
      - uses: actions/checkout@v4

      - name: Download Docker Images
        uses: actions/download-artifact@v4
        with:
          name: docker-images
      - name: Load Docker Images
        run: docker load -i cdp-images.tar

      - name: Determine the category
        id: category
        run: |
          image=${{ matrix.image }}
          category=${image%%:*}
          echo "category=$category" >> $GITHUB_OUTPUT
      - name: Scan ${{ matrix.image }}
        uses: anchore/scan-action@v5
        id: scan
        with:
          image: "${{ matrix.image }}"
          fail-build: false
          severity-cutoff: critical
          output-format: sarif
      - name: Upload Image Vulnerability Reports
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ steps.scan.outputs.sarif }}
          category: ${{ steps.category.outputs.category }}

  publish:
    if: (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')) && github.repository_owner == 'cabinetoffice'
    runs-on: ubuntu-latest
    name: Publish containers
    needs: [test, package]
    env:
      DOCKER_BUILDKIT: 1
      COMPOSE_DOCKER_CLI_BUILD: 1
      IMAGE_VERSION: ${{ needs.package.outputs.version }}
      IMAGES: ${{ needs.package.outputs.images }}

    steps:
      - uses: actions/checkout@v4

      - name: Download Docker Images
        uses: actions/download-artifact@v4
        with:
          name: docker-images

      - name: Load Docker Images
        run: docker load -i cdp-images.tar

      - name: Set up AWS CLI
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-2

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Tag and Push Docker Images
        run: make aws-push-to-ecr AWS_ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}" IMAGES="${{ env.IMAGES }}"

      - name: Store Version in SSM Parameter Store
        run: |
          aws ssm put-parameter --name "cdp-sirsi-service-version" --value "${{ env.IMAGE_VERSION }}" --type String --overwrite
